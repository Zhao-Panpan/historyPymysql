
### sql解析

#### 前提条件

- 开启使用历史拉链表功能，创建数据库连接池或者连接数据库时传入参数operate_history即可
- 必须指定历史拉链表中关联主表的那些字段，默认历史拉链表关联字段为 base_ + 主表中的字段，比如id，历史拉链表中的关联字段就为base_id，指定
关联主表字段的属性为base_column
- 需要提前在数据库中创建对应的历史拉链关联表，后缀默认为 主表名+ _history,可以指定后缀，参数为 postfix
- 创建历史拉链表时，如果主表中存在 modified_time字段，需要在历史拉链表中去除 on update current_timestamp。如果主表中存在索引，拉链表中不创建索引

#### 使用依赖

- 需要安装pymysql或者aiomysql。历史拉链表是在pymysql和aiomysql的基础上再次封装的一层，对于使用者是无感知的，不需要其他操作，开启后，正常使用pymysql模块即可
- 需要安装sqlparser，sql的解析是使用sqlparser模块来解析的


#### 内部使用流程

指定数据库操作时，不论是pymysql还是aiomysql模块，都是创建连接，获取光标，执行sql语句，获取结果

使用pymysql或者aiomysql执行sql语句时，都需要调用 execute 或者 exectemany（批量操作）

1. 首先 先判断是否开启了历史拉链功能，使用者可以在调用执行方法时，传入是否开启历史拉链功能，局部控制的权限比重高于全局控制

2. 解析sql，判断sql类型，因为历史拉链表适用于记录数据的变更的，所以对于查询操作，不做任何额外操作。因此如果sql类型为查询，则跳过。

a. 当sql类型为 insert 插入操作时，步骤如下:

- 执行原本的 insert 操作, 返回数据库变动个数
- 获取新增数据的主键id，和 数据库变动条数
- 解析 insert操作的 主表名称
- 通过主表名称，获取该表中的所有字段名称，同时要过滤掉base_column(关联字段)
- 根据主表名 + 主表中过滤后的所有字段 + base前缀的关联字段 拼接 插入历史拉链表的sql语句
- 插入历史拉链表数据

b. 当sql类型为 update 操作时，步骤如下：

- 解析update sql语句中是单表更新还是多表更新，有无使用表别名，待更新的字段以及 过滤条件
- 同时对传入参数进行过滤处理，区分哪些参数是待更新对数据，哪些数据是条件参数
- 通过主表名获取该表的所有字段名称
- 根据主表名称以及更新条件查询待更新数据的主键id值
- 修改所有关联主键id值为待更新的id值并且record_end_time的值为默认值的对应历史拉链表中数据的 record_end_time的值为当前时间
- 执行原表中的更新操作语句
- 根据表名 + 表中字段 + 关联字段 拼接 sql语句，在历史拉链表中插入一条更新后的原表数据

c. sql类型为 delete 操作时，步骤如下:

- 解析 delete sql 语句中是否为多表删除，有无使用表别名，待删除的表名以及 删除条件
- 根据表名以及 删除条件，查询待删除数据的主键id值
- 通过主表名获取该表的所有字段名称
- 修改对应历史拉链表中 关联主键id为 待删除数据id的并且record_end_time的值为默认值的对应历史拉链表中数据的 record_end_time的值为当前时间
- 执行原表的删除操作
- 根据表名 + 表中字段 + 关联字段 拼接 sql语句，在历史拉链表中插入一条删除前的原表数据，record_end_time、record_end_time的值为当前时间
